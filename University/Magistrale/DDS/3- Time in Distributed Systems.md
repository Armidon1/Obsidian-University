
## Time in Distributed Systems

**Physical Clocks and Clock Synchronization**

---

## Introduction

In a Distributed System:

- Processes run on different nodes interconnected by a network (LAN or WAN).
    
- Processes cooperate to complete a computation.
    
- Processes communicate only through message passing.
    

Many applications require **ordering between events** and **time synchronization** to operate correctly:

- Air traffic control
    
- Network monitoring
    
- Stock market trading
    
- Industrial automation, etc.
    

> 🕒 Time is a **critical factor** for distributed systems!

---

## Why Time Is So Important?

Time is a quantity we need to measure — and many algorithms depend on it.

### Examples

- Data consistency
    
- Authentication
    
- Avoiding double processing
    

Ordering events correctly is **fundamental** to solving these problems.

---

## Why Using Time in Distributed Systems Is Difficult

Because all processes must **agree on a common time reference** — and this is hard to achieve when nodes are geographically distributed and communication delays vary.

---

## System Model

A distributed system is composed of a set of processes:

[  
\Pi = {p_1, p_2, \ldots, p_n}  
]

Each process:

- Runs on a mono-processor machine with no shared memory.
    
- Has a state `s_i`, including the values of all its variables.
    
- Changes its state through actions during execution.
    
- Communicates only by sending and receiving messages.
    

---

## Computation Model

Each process generates a **sequence of events**:

- Internal events (state changes)
    
- External events (send/receive)
    

Denote with `e_i^k` the k-th event generated by process `p_i`.

The computation evolution can be represented with a **space-time diagram**.

---

## History of Computations

Within a process `p_i`, define the _happened-before_ relation:

[  
e \rightarrow_i e' \quad \text{iff } e \text{ occurs before } e' \text{ in } p_i  
]

- **Local History**: ordered sequence of events of a process
    
- **Partial Local History**: prefix of a local history
    
- **Global History**: union of all local histories across processes
    

[  
H = \bigcup_{i=1}^{n} h_i  
]

---

# Time in Distributed Systems

---

## Timestamping

Each process attaches a **label** (timestamp) to each event.  
This helps reconstruct a global ordering of events.

### Naïve Solution

Each process timestamps events using its **local physical clock**.

---

## The Problem with Timestamping

- Within a single process, we can always order events.
    
- Across multiple processes, however, local timestamps differ — due to:
    
    - Network delays
        
    - Variable processing times
        
    - Lack of a global clock
        

Thus, achieving a **common global clock** is impossible.

---

## Practical Solution

We can synchronize **physical clocks approximately** using algorithms, obtaining a bounded synchronization error.

Each process uses its **local clock**, synchronized within a known accuracy.

---

# Physical Computer Clocks

---

## Hardware and Software Clocks

Each process reads its **local hardware clock** via the operating system.

- Hardware clock = oscillator + counter register.
    
- OS reads hardware clock ( H_i(t) ) to obtain **software clock**:
    

[  
C_i(t) = \alpha H_i(t) + \beta  
]

Example: 64-bit counter representing nanoseconds elapsed.

---

## Accuracy and Resolution

`C_i(t)` approximates real time `t`, but it is imperfect:

- Differs from actual time due to hardware precision.
    
- Differs between nodes.
    

**Resolution requirement:**  
[  
T_{resolution} < \Delta T  
]  
where ( \Delta T ) is the minimum distinguishable interval between two events.

---

# Parameters Affecting Synchronization Accuracy

|Parameter|Description|
|---|---|
|**Skew**|Difference between two clocks: (|
|**Drift Rate**|Gradual divergence from real time; deviation per second.|

Example:

- Drift rate = 2 μs/s → clock gains 2 μs every second.
    
- Typical quartz clocks drift ≈ 1s every 11–12 days (10⁻⁶ s/s).
    
- High-precision clocks drift ≈ 10⁻⁷–10⁻⁸ s/s.
    

---

# Universal Time Coordinated (UTC)

**UTC** is the international standard time reference.  
Based on **atomic time**:  
1 second = 9,192,631,770 transitions of a cesium atom.

Atomic clocks are extremely precise (drift ≈ 10⁻¹³).

---

# Internal and External Synchronization

## External Synchronization

Processes synchronize with an **authoritative external source** (e.g., UTC).

For a synchronization bound ( D > 0 ):  
[  
|S(t) - C_i(t)| < D \quad \forall i  
]

→ Clocks are _externally synchronized_ within ( D ).

---

## Internal Synchronization

Processes synchronize **with each other**.

For all ( i, j ):  
[  
|C_i(t) - C_j(t)| < D  
]

→ Clocks _agree within_ ( D ).

---

## Relationship Between Them

- Externally synchronized ⇒ internally synchronized (within ( 2D )).
    
- Internally synchronized clocks may still drift from real UTC time.
    

---

# Correct Clocks

---

## Correct Hardware Clock

A hardware clock ( H ) is _correct_ if its **drift rate** is bounded by ( \rho ):  
[  
1 - \rho \le \frac{dC}{dt} \le 1 + \rho  
]

Then, for any interval [t, t′]:  
[  
(1 - \rho)(t' - t) \le H(t') - H(t) \le (1 + \rho)(t' - t)  
]

### Resynchronization Rule

Maximum skew ( D ) → resynchronize at least every ( D / 2\rho ) seconds.

---

## Correct Software Clock

- Must be **monotonic**:  
    ( t' > t \Rightarrow C(t') > C(t) )
    
- Achieved by tuning parameters ( \alpha, \beta ).
    

### Failure Types

- **Crash failure** → clock stops.
    
- **Arbitrary failure** → unpredictable behavior (e.g., Y2K bug).
    

> Correctness ≠ Accuracy.

---

# Synchronization Algorithms

---

## Synchronization via Time Server

### Centralized Time Service

- **Request-driven** or **broadcast-based**.
    

### Examples

- **Christian’s Algorithm**
    
- **Berkeley’s Algorithm (Gusella & Zatti, 1989)**
    
- **Network Time Protocol (NTP)**
    

---

## Christian’s Algorithm

External synchronization via a **time server S** connected to a UTC source.

Works even in asynchronous systems (probabilistically).

### Procedure

1. Process `p` sends a request message `m_r` to `S`.
    
2. Server replies with timestamp `t` in message `m_t`.
    
3. Process sets:  
    [  
    C_p = t + \frac{RTT}{2}  
    ]
    

### Notes

- Works if RTT is small and stable.
    
- Multiple servers improve reliability.
    
- Server failures and attacks must be handled.
    

---

## Accuracy of Christian’s Algorithm

Accuracy:  
[  
\pm (RTT/2 - t_{min})  
]

where ( t_{min} ) = minimum network delay.

Example:

- RTT = 70 ms, ( t_{min} = 30 ) → accuracy ±5 ms
    
- RTT = 70 ms, ( t_{min} = 20 ) → accuracy ±15 ms
    

---

## Discussion

- The server is a **single point of failure**.
    
- Possible solution: **multiple synchronized servers**.
    
- Add redundancy and authentication for security.
    

---

# Berkeley’s Algorithm

**Internal synchronization** — master/slave structure.

### Steps

1. Master polls all processes for their local time.
    
2. Each slave responds with its timestamp.
    
3. Master calculates differences and computes average (excluding faulty clocks).
    
4. Sends correction to all processes.
    

---

### Example

|Process|Local Time|Δ (diff)|
|---|---|---|
|Master|3:05|0|
|p₁|2:55|-10|
|p₂|3:00|-5|
|p₃|3:25|+20|

Average: (-15 / 3) = -5  
Corrections:

- Master: -5
    
- p₁: +5
    
- p₂: 0
    
- p₃: -25
    

---

### Accuracy and Fault Tolerance

- Depends on **maximum RTT**.
    
- Ignores clocks with RTT > threshold.
    
- If master fails → new master elected.
    
- Tolerates arbitrary slave behavior (e.g., outliers).
    

---

### Note on Slowing Down Clocks

Clocks **cannot be set backwards** (would break event ordering).  
To slow down a clock:

- Hide interrupts (skip updates for a certain period).
    

---

# Network Time Protocol (NTP)

Time synchronization over the Internet.

### Characteristics

- Synchronizes clients to UTC.
    
- Reliable via **redundant servers and paths**.
    
- **Scalable** (hierarchical architecture).
    
- **Secure** (authentication mechanisms).
    

---

## NTP Hierarchy

1. **Primary servers** connected to UTC.
    
2. **Secondary servers** synchronized to primary ones.
    
3. **Clients** synchronize to secondary servers.
    

NTP is the **de facto standard** for clock synchronization online.

---

## Synchronization Modes

|Mode|Description|
|---|---|
|**Multicast**|Server periodically broadcasts current time (low accuracy, used in LANs).|
|**Procedure Call**|Client requests current time (high accuracy, like Cristian’s algorithm).|
|**Symmetric**|Used among time servers for mutual synchronization (higher hierarchy levels).|

---

# Time in Asynchronous Systems

In asynchronous systems:

- Perfect synchronization is impossible.
    
- Accuracy depends on known **upper/lower bounds** on delays.
    
- Clocks can only be synchronized **with certain probability**.
    

---

## Key Takeaways

- Time synchronization is essential for distributed systems.
    
- Perfect synchronization is unattainable; bounded accuracy is achievable.
    
- Algorithms like **Christian**, **Berkeley**, and **NTP** balance accuracy, scalability, and fault tolerance.
    

---

## References

- C. Cachin, R. Guerraoui, L. Rodrigues – _Introduction to Reliable and Secure Distributed Programming_, Springer 2011
    
- Gusella & Zatti (1989) – _Berkeley UNIX Time Synchronization_
    
- RFC 5905 – _Network Time Protocol Version 4 Specification_
    

---

