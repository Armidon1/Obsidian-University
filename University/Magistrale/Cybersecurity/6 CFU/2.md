# Slide 1

## Stream ciphers

1

old, but now back in the spotlight 

---

# Slide 2

## Secret key cryptography

2

Alice and Bob share
A crypto protocol E
A secret (symmetric) key K 
They communicate using E with key K
Adversary knows E, knows some exchanged messages but ignores K

Two approaches: 
Stream Ciphers
Block ciphers

---

# Slide 3

## Stream ciphers

3

define a secret key (seed)

using the seed generate a byte stream (keystream): i-th byte is function of
  - only key (synchronous stream cipher), or 
  - both key and first i-1 bytes of ciphertext asynchronous stream cipher)

obtain ciphertext by bitwise XORing plaintext and keystream

---

# Slide 4

## Synchronous stream cipher

4

=



key

ciphertext

keystream

plaintext



encryption

---

# Slide 5

## Synchronous stream cipher

5

=



key

plaintext

keystream

ciphertext



decryption

---

# Slide 6

## Synchronous stream ciphers in practice

6

Many ciphers before 1940

Enigma - II world war (Germany)

A5 – GSM (encryption cell phone-base station) 

WEP - used in Ethernet 802.11 (wireless)

RC-4  (Ron’s Code, used by WEP)

---

# Slide 7

## A5/1 stream cipher

7

Developed in 1987, used to ensure over-the-air communication privacy in the GSM cellular telephone standard
A major dispute arose in the mid-1980s between NATO signal intelligence agencies about whether GSM encryption should be strong or intentionally weakened
Used in both Europe and the United States. A related variant, A5/2, was a deliberately weakened version intended for export to certain regions
The design was initially kept secret, but leaked in 1994 and fully reverse-engineered in 1999 by Marc Briceno
Multiple serious vulnerabilities in the cipher were subsequently identified

---

# Slide 8

## RC-4

8

RC: Ron’s Code 
  - (Ron = Ronald Rivest, MIT, born in 1947 in NY state)
Considered safe: 1987 - 1994 kept secret, after ‘94 extensively studied 
  - insecure from 2004
Good for exporting (complying with US restrictions)
Easy to program, fast 
Very popular: Lotus Notes, SSL, Wep etc.
RC4's weak key schedule can give rise to a variety of serious problems

Rivest

---

# Slide 9

## RC-4 weaknesses

9

Biased output in early keystream bytes

Vulnerable if keys are reused

Broken in protocols like WEP and TLS (early versions)


Today deprecated

---

# Slide 10

## RC-4 properties

10

variable key length (byte) 
synchronous
starting from the key, it generates an apparently random permutation
eventually the sequence will repeat 
however, long period > 10100
very fast: 1 byte of output requires 8-16 instructions


---

# Slide 11

## RC-4 initialization

11

Goal: generate a (pseudo)random permutation of the first 256 natural numbers

j=0
S0=0, S1=1, …, S255=255
Assume a key of 256 bytes k0,…,k255 (if the key is shorter, repeat) 
for i=0 to 255 do
  - j = (j + Si+ ki) mod 256
  - exchange Si and Sj 

In this way we obtain a permutation of  0, 1, …,255, the resulting permutation is a function of the key

---

# Slide 12

## RC-4 keystream generation

12

Input: permutation S of 0, 1, …, 255
i = 0, j = 0
while (true)
  - i = (i + 1) mod 256
  - j = (j + Si) mod 256
  - exchange Si and Sj
  - t = (Si + Sj) mod 256
  - k = St 	// compute XOR
  - 
at every iteration compute the XOR between k and next byte of plaintext (or ciphertext)

---

# Slide 13

## Perfect ciphers and One-Time Pad

13

---

# Slide 14

## Perfect ciphers

14

---

# Slide 15

## Conditional probabilities

15

---

# Slide 16

## One-time pad (OTP)

16

---

# Slide 17

## Features of OTP

17

---

# Slide 18

## Proof of Shannon's theorem

18

---

# Slide 19

## Consequences

19

OTP is perfect if
  - keystream truly random
  - keystream space not less message space
if seed (key) is reused we get same keystream K for two different encryptions. Heavy consequences
  - C1 = P1  K, C2 = P2  K
  - Assume pair plaintext, ciphertext (P1, C1) known (KPA)
  - Attacker computes C1  C2 = P1  K  P2  K
  -  commutative and associative, so: C1  C2 = P1  P2  K  K = = P1  P2 (by properties of )
  - P1  P2  P1 (known) = P2 (Success!)
  - 

---

# Slide 20

## Conclusion

20

OTP is not obsolete
it needs a truly random long keystream
  - PRNG not enough
not to be reused
This makes OTP unpractical
Otherwise... OTP is theoretically unbreakable (the only with proved perfect security)


---

# Slide 21

## ChaCha20

21

---

# Slide 22

## ChaCha20, a synchronous stream cipher

22

Objectives
Understand the design and purpose of ChaCha20
Compare it to older stream cipher models
Learn how ChaCha20 builds on the one-time pad concept


---

# Slide 23

## Background & history

23

Designed in 2008 by Daniel J. Bernstein as an improvement of Salsa20
Standardized in RFC 8439 by the IETF
Focus: high speed, simplicity, and resistance to timing attacks
Adopted in security-critical applications like TLS 1.3, OpenSSH, WireGuard, Signal, etc.

---

# Slide 24

## Stream ciphers recap

24

Stream ciphers generate a keystream and encrypt data by XORing it with plaintext
Fast, low-latency encryption ideal for real-time applications
Example: the One-Time Pad — perfectly secure but impractical

---

# Slide 25

## From OTP to ChaCha20

25

ChaCha20 mimics the One-Time Pad by generating a pseudo-random keystream
Key idea: instead of a long random keystream, we use a small key + counter + nonce (random number to be used once) to generate keystream blocks
XOR remains the central operation, just like OTP

---

# Slide 26

## Inputs to ChaCha20

26

256-bit key: shared secret
96-bit nonce: unique per message/session
32-bit block counter: changes per block to ensure keystream uniqueness
  - a block is a chunk of 512 bits of plaintext
These inputs determine the internal state that drives the keystream

---

# Slide 27

## Block structure

27

512-bit state divided into 16 32-bit words
  - 384 bits are variable and 128 are coming from constants
Layout
  - 4 constant words
  - 8 key words
  - 1 counter word
  - 3 nonce words
This state is transformed to produce 64-byte keystream blocks

---

# Slide 28

## Quarter-round function

28

Core operation: processes 4 words (from state) with Add, Rotate, XOR (ARX)
Lightweight and fast on all CPUs
Provides diffusion and non-linearity
Designed for simplicity and timing safety

---

# Slide 29

## 10 Double-rounds and output 

29

ChaCha20 performs 20 operations, organized as 10 double-rounds
Each double-round consists of
  - 1 column-wise operation: applies 4 Quarter-Round functions to the columns of the 4×4 word matrix
  - 1 diagonal-wise operation: applies 4 Quarter-Round functions to the diagonals of the matrix
1 double-round = 8 Quarter-Round functions
These transformations ensure that all 16 words of the state are thoroughly mixed in a defined pattern
After all 10 double-rounds: add the final state to the original state (mod 2^32) to get 64 bytes of keystream

---

# Slide 30

## Encryption with XOR

30

ciphertext = plaintext ⊕ keystream
Same operation used for decryption: plaintext = ciphertext ⊕ keystream
Stateless per block: no chaining between blocks required

---

# Slide 31

## Security goals of ChaCha20

31

Designed to resist
  - Key recovery
  - Keystream prediction
  - Timing attacks
No known practical attacks on full 10 double-round version
High performance across platforms, even without hardware support

---

# Slide 32

## Real-world usage

32

TLS 1.3: used as an option (in addition to others) for secure web traffic
Signal, WhatsApp: encrypt messages using ChaCha20 (or other, depending on context)
WireGuard VPN: lightweight and fast encryption
OpenSSH: option for encrypted shell sessions, now less used


---

