# Slide 1

## Block ciphers: an introduction

1

---

# Slide 2

## Definition of block cipher

2

Given
block P of plaintext of h bits (h fixed)
a key k of fixed # of bits

a cryptographic protocol Ek produces 
a block C of h bits, function of P and k
(for a fixed E)

Note: lengths of both block and key (# of bits) are fixed (not necessarily equal)

---

# Slide 3

## Features

3

Encrypts fixed-size blocks of plaintext into ciphertext (e.g., 128 bits)
Uses a secret key to control a deterministic transformation
Always produces the same ciphertext for the same input and key
Decryption is the reverse transformation using the same key
Acts as a reversible function and is a foundational building block in cryptography

---

# Slide 4

## Visual Analogy

4

Imagine plaintext as a piece of clay
The key is a custom mold
Cipher shapes the clay into ciphertext
Same mold = same result
Emphasizes determinism and non-random transformation

---

# Slide 5

## Block vs. stream ciphers

5

Block cipher: encrypts blocks (e.g., 128 bits) at a time
Stream cipher: encrypts one bit or byte at a time using a keystream
Analogy:
  - Stream = faucet
  - Block = stamping machine
Block ciphers: better for structured data
Stream ciphers: better for real-time communication

---

# Slide 6

## More detailed comparison

6

Block ciphers work on fixed-size blocks (e.g., 128 bits). This makes them ideal for
  - Files: data is usually stored in known formats (PDF, DOCX, etc.)
  - Database records: entries have regular sizes and are accessed in blocks
  - Disk sectors: operating systems read and write data in 512-byte or 4096-byte blocks
These are structured environments, where data is chunked in a way that fits naturally with the block cipher‚Äôs operation


---

# Slide 7

## Desired properties

7

Invertibility: must be able to recover original plaintext
Avalanche effect: small changes = big output changes
Non-linearity: avoids predictability and simple math reversal
Key sensitivity: small key differences yield vastly different outputs
These features strengthen resistance to cryptanalytic attacks

---

# Slide 8

## Applications

8

File encryption
Disk encryption (full disk, partitions)
Encrypted RAM/memory
Encrypted communication packets
Database field/row encryption
Deployed in virtually all modern security systems

---

# Slide 9

## Block cipher designs from the late 20th century 

9

---

# Slide 10

## Late-millennium block ciphers 1  

10

DES, 3-DES - (1976; 64-bit block, 56 bit key)
RC-2 (1987)
  - designed for exporting cryptography within IBM Lotus Notes
  - 64-bit block, variable key size, vulnerable to an attack using 234 chosen plaintexts
IDEA (1991)
  - 64-bit block, 128 bit key
  - Strong, only weakened variants have been broken, outdated
Blowfish (1993)
  - 64-bit block size and a variable key length from 32 up to 448 bits
  - Still strong but deprecated


---

# Slide 11

## Late-millennium block ciphers 2  

11

RC5 (1994)
  - variable block size - 32, 64 or 128 bits - key size (0 to 2040 bits) and number of rounds (0 to 255). The original suggested choice of parameters were a block size of 64 bits, a 128-bit key and 12 rounds
  - Distributed.net has brute-forced RC5 messages encrypted with 56-bit and 64-bit keys and is working on cracking a 72-bit key; as of January 2025, 12% of the keyspace has been searched. At the current rate, it will take approximately 35-60 years to test every possible remaining key
  - distributed.net (or Distributed Computing Technologies, Inc. or DCTI) is a worldwide distributed computing effort that is attempting to solve large scale problems using otherwise idle CPU or GPU time. It is a non-profit organization
AES (Rijndael, 2001) 
  - 128-bit block, 128-256 bit key
  - Very strong

---

# Slide 12

## Historic note

12

DES (data encryption standard) is a symmetric block cipher using 64-bit blocks and a 56-bit key
Developed at IBM, approved by the US government (1976) as a standard.  Size of key (56 bits) was apparently small enough to allow the NSA (US national security agency) to break it exhaustively even back in 70‚Äôs.
In the 90‚Äôs it became clear that DES is too weak for contemporary hardware & algorithmics (Matsui ‚Äúlinear attack‚Äù, requires only 243 known plaintext/ciphertext pairs; in 1999 Deep Crack and distributed.net broke a DES key in 22 hours and 15 minutes)

---

# Slide 13

## More history

13

The US government NIST (National Inst. of standards and technology) announced a call for an advanced encryption standard in 1997
This was an international open competition. Overall, 15 proposals were made and evaluated, and 6 were finalists. Out of those, a proposal named Rijndael, by Daemen and Rijmen (two Belgians), was chosen in February 2001 

---

# Slide 14

## Final ranking in NIST competition

14

not official

---

# Slide 15

## Iterating DES

15

Due to the weakness of DES the approach of iterating DES has been explored
3DES(M, k1, k2, k3) = encrypt plaintext, then encrypt ciphertext, then encrypt new ciphertext
  - 3DES(M, k1, k2, k3) = DES(DES(DES(M, k1), k2), k3), that gives the illusion of a security against brute-force of 56√ó3 bits = 168 bits
  - For the three levels 3DES often uses an encryptor, a decryptor, an encryptor (called in this case 3DES-EDE)
  - But attack Meet-in-the-Middle (next slide) reduces such length to 112 bits
Iterating can be used (theoretically) with other ciphers

---

# Slide 16

## More on iterating

16

Plaintext undergoes encryption repeatedly by underlying cipher
Ideally, each stage uses a different key
In practice triple cipher is usually 
  - C = Ek1(Ek2(Ek1(P))) [EEE mode] or
  - C = Ek1(Dk2(Ek1(P))) [EDE mode]
EDE is more common in practice

---

# Slide 17

## Ways of iterating DES

17

Sometimes only two keys are used in 3DES
Identical key must be at the beginning and the end
Legal advantage (export license) due to smaller overall key size
Why not using 2DES?


---

# Slide 18

## MITM ‚Äì Meet-in-the-Middle

18

Not to be confused with Man-in-the-Middle
Requirements (assume EE)
  - Known plaintext/ciphertext pairs
  - 2n encryptions + 2n decryptions (2 keys of n bit), instead of 22n brute-force
  - 2n memory space
Idea: try all possible 2n encryptions of the plaintext and all possible 2n decryptions of the ciphertext. Encryptions stored into a lookup table
Check for a pair of keys that transform the plaintext in the ciphertext. Test pair on other pairs plaintext/ciphertext
Note: the method can be applied to all block ciphers  

---

# Slide 19

## MITM ‚Äì Meet-in-the-Middle

19

MITM can be (theoretically) applied on s iterations
If key-length is sn, brute-forcing the iteration doesn't require 2sn attempts, but only (about) 2sn/2
MITM needs huge memory 
For 3 or more iterations, memory becomes impractical
Triple encryption is the realistic upper bound


---

# Slide 20

## Advanced Encryption Standard

20

---

# Slide 21

## AES

21


Symmetric block cipher (block size: 128 bits = 16 bytes)

Key lengths: 128, 192, or 256 bits

Approved US standard (2001)

Finite fields algebra

---

# Slide 22

## Noteworthy math results

22

Euler theorem
If a ed n are coprime  positive integers (i.e. GCD(a, n) = 1) and ùúë(n) is the is¬†Euler's totient function (how many positive integers not greater than n are coprime with n)
aùúë(n) ‚â° 1 (mod n)


B√©zout's identity
Let¬†a¬†and¬†b¬†be¬†nonzero integers¬†with¬†greatest common divisor¬†d. Then there exist signed integers¬†x¬†and¬†y¬†such that¬†ax¬†+¬†by¬†=¬†d
x and y can be computed by the extended Euclidean algorithm

---

# Slide 23

## Challenge

23


compute 
2200 mod 127 

using only pen, paper and Euler theorem‚Ä¶

---

# Slide 24

## Notation

24

Zn = {[0], [1], [2], ‚Ä¶, [n-1]}
  - here [i] is the equivalence class of integers congruent to i (mod n)
  - for brevity people often write Zn = {0, 1, 2, ‚Ä¶, n-1}
  - quotient set commonly called ring of integers modulo n
Zm* = multiplicative group modulo m
  - natural numbers mod m that are relatively prime (co-prime) to m
  - Zm* ‚äÜ Zm

---

# Slide 25

## Totient function

25

previous definitions

ùúë(m) = Euler‚Äôs totient function = |Zm*| = size of the multiplicative group of Zm


---

# Slide 26

## Galois field GF(pk)

26

√âvariste Galois (1811-1832)




Theorem: for every prime power pk (k ‚àà ‚Ñï+) there is a unique finite field containing pk elements. These fields are denoted by GF(pk)

There are no finite fields with other cardinalities



26

---

# Slide 27

## Implementing  GF(pk) arithmetic

27

Theorem: Let f(x) be an irreducible polynomial of degree k over Zp. 
The finite field GF(pk) can be realized as the set of degree k-1 polynomials over Zp, with addition and multiplication done modulo f(x)


27

---

# Slide 28

## Implementing  GF(25)

28

28

Addition: bit-wise XOR (since 1+1=0)

          x3+x+1         (0,1,0,1,1)
          +  
   x4+ x3+x             (1,1,0,1,0)
-------------------------------
   x4                 +1         (1,0,0,0,1)

---

# Slide 29

## Implementing  GF(25)

29

29

Multiplication: polynomial multiplication, and then remainder modulo the defining polynomial f(x)

For small size finite field, a lookup table is the most efficient
method for implementing multiplication.

    (1,1,0,1,1)*(0,1,0,1,1)

   =   (1,1,0,0,1)



Maple

---

# Slide 30

## AES - Advanced Encryption Standard

30

 Symmetric block cipher
 Key lengths: 128, 192, or 256 bits
  - original Rijndael supports more lengths

Rationale
Resistance to all known attacks
Speed and code compactness 
  - good for devices with limited computing power, e.g. smart cards
Simplicity

---

# Slide 31

## AES Specifications

31

Input & output block length: 128 bits
State: 128 bits, arranged in a 4-by-4 matrix of bytes

each byte is viewed as an element in GF(28)

Input/Output: A0,0, A1,0, A2,0, A3,0, A0,1,‚Ä¶

---

# Slide 32

## AES Specifications

32

  Key length: 128, 196, 256 bits

Cipher Key Layout: n = 128, 196, 256 bits, arranged in a 
4-by-n/32 matrix of bytes

Initial layout: K0,0, K1,0, K2,0, K3,0, K0,1,‚Ä¶

---

# Slide 33

## AES Specifications

33

High level code

AES(State, Key)
  - KeyExpansion(Key, ExpandKey)
  - AddRoundKey(State, ExpandKey[0])
  - for (i = 1; i < R; i++) do 		Round(State, ExpandKey[i]);
  - FinalRound(State, ExpandKey[R]);

---

# Slide 34

## Encryption: Carried out in rounds

34

---

# Slide 35

## Rounds in AES

35

128 bits AES uses 10 rounds, no shortcuts known for 6 rounds
  - The secret key is expanded from 128 bits to 10 round keys, 128 bits each
  - Each round changes the state, then XORs the round key (for longer keys, add one round for every extra 32 bits)

Each rounds complicates things a little 
Overall, it seems infeasible to invert without the secret key  (but easy given the key)


---

# Slide 36

## AES Specifications: One Round

36

Transform the state by applying:

Substitution
Shift rows
Mix columns
XOR round key

---

# Slide 37

## Substitution (S-Box)

37

Substitution operates on every byte separately: Ai,j <-- Ai,j-1 (multiplicative inverse in GF(28) which is highly nonlinear)

If Ai,j = 0, don‚Äôt change Ai,j

Clearly, the substitution is invertible 


---

# Slide 38

## Cyclic shift of rows

38

no shift
  shift 1 position
     shift 2 positions
         shift 3 positions 

Clearly, the shift is invertible

---

# Slide 39

## Mixing Columns 

39

Every state column is considered as a polynomial over GF(28)
Multiply with an invertible polynomial
03 x3 + 01x2 + 01x + 02 (mod x4 + 1)
Inv = 0B x3 + 0D x2 +09 x + 0E

Round: SubBytes(State)
             ShiftRows(State)
             MixColumns(State)
             AddRoundKey(State,ExpandedKey[i])


---

# Slide 40

## Key Expansion

40

Generate a ‚Äúdifferent key‚Äù per round

Need a 4 x 4 matrix of values (over GF(28)) per round

Based upon a non-linear transformation of the original key

Details available: The Design of Rijndael, Joan Daemen and Vincent Rijmen, Springer

---

# Slide 41

## Animation

41

time 4' 25''

---

# Slide 42

## Introduction to block cipher modes of operation

42

---

# Slide 43

## Block cipher modes of operation

43

block ciphers operate on blocks of fixed length, often 64 or 128 bits
because messages may be of any length, and because encrypting the same plaintext under the same key always produces the same output,

	several modes of operation have been invented which allow block ciphers to provide confidentiality for messages of arbitrary length

---

# Slide 44

## ECB Mode Encryption(Electronic Code Book)

44

encrypt each plaintext block separately

---

# Slide 45

## Properties of ECB

45

Simple and efficient
Parallel implementation possible
Does not conceal plaintext patterns
Active attacks are possible (plaintext can be 
   easily manipulated by removing, repeating, 
   or interchanging blocks)

Only teaching purposes

---

# Slide 46

## ECB: plaintext repetitions 

46

       plaintext		   ciphertext ECB        good ciphertext 

---

# Slide 47

## CBC (Cipher Block Chaining) mode

47

Previous ciphertext is XORed with current plaintext before encrypting current block
Seed (called initialization vector, or IV) is used to start the process; it can be sent without encryption
Seed = 0 safe in most but NOT all cases (e.g., assume the file with salaries is sent once a month, with the same seed we can detect changes in the salaries) therefore a random seed is better

---

# Slide 48

## CBC (Cipher Block Chaining): decryption

48

IF a transmission error changes one bit of C(i-1) 
THEN block mi changes in a predictable way (this can be exploited by adversary)
BUT there are unpredictable changes in m(i-1);
Solution: always use error detecting codes (for example CRC) to check quality of transmission

---

# Slide 49

## Properties of CBC

49

Asynchronous stream cipher
Errors in one ciphertext block don‚Äôt propagate much
  - a one-bit change to the ciphertext causes complete corruption of the corresponding block of plaintext, and inverts the corresponding bit in the following block of plaintext
Conceals plaintext patterns
No parallel encryption
Yes parallel decryption
Plaintext cannot be easily manipulated
Standard in many systems: SSL, IPSec etc.

---

# Slide 50

## More on CBC

50

message must be padded to a multiple of the cipher block size
  - one way to handle this issue is ciphertext stealing (next slide)
a plaintext can be recovered from just two adjacent blocks of ciphertext
  - therefore, decryption can be parallelized
  - usually a message is encrypted once, but decrypted many times

---

# Slide 51

## Ciphertext stealing

51

general method that allows for processing of messages that are not evenly divisible into blocks
  - without resulting in any expansion of the ciphertext
  - at the cost of slightly increased complexity
consists of altering processing of the last two blocks of plaintext, resulting in a reordered transmission of the last two blocks of ciphertext (and no ciphertext expansion)
suitable for ECB and CBC
from NIST website http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/ciphertext%20stealing%20proposal.pdf 

---

# Slide 52

## Stealing procedures

52

Encryption procedure
Apply standard CBC encryption to all complete blocks
If the last block is partial, process the previous full block normally
Use the ciphertext of the previous block to fill the partial block (ciphertext stealing)
Swap the last two ciphertext blocks
Transmit the ciphertext as-is (possibly non-multiple of block size)

Decryption procedure
Requires knowledge of original plaintext length
Swap the last two ciphertext blocks back to original order
Decrypt with CBC as usual
Discard the extra bytes to recover the correct final block

---

# Slide 53

## Stealing diagram

53

---

# Slide 54

## OFB and CTR

54

---

# Slide 55

## OFB Mode (Output FeedBack)

55

Makes a block cipher into a synchronous stream cipher: it generates keystream blocks, which are then XORed with the plaintext blocks to get the ciphertext 
Flipping a bit in the ciphertext produces a flipped bit in the plaintext at the same location. This property allows many error correcting codes to function normally even when applied before encryption




---

# Slide 56

## OFB scheme:encryption

56

An initialization vector IV is used as a "seed" for a sequence of data blocks 

---

# Slide 57

## OFB scheme: decryption

57

Still encryptors because same keystream must be produced

---

# Slide 58

## OFB math

58

Because of the symmetry of the XOR operation, encryption and decryption are exactly the same

Ci = Pi ÔÉÖ Oi
Pi = Ci ÔÉÖ Oi
Oi = Ek(Oi-1)
O0 = IV

---

# Slide 59

## OFB  mode

59

Discussion
If Ek is public (known to the adversary) then initial seed must be encrypted
If E is a cryptographic function that depends on a secret key, then initial seed can be sent in clear
Initial seed must be modified for EVERY new encryption
Extension: it can be modified in such a way that only k bits of each keystream block are used to compute the ciphertext (k-OFB)

---

# Slide 60

## Properties of OFB

60

Synchronous stream cipher
Errors in ciphertext do not propagate
Pre-processing is possible
Conceals plaintext patterns
No parallel implementation known
Active attacks by manipulating plaintext are possible

---

# Slide 61

## CTR (Counter Mode)

61

Aka Integer Counter Mode (ICM) and Segmented Integer Counter (SIC) mode
turns a block cipher into a stream cipher: it generates the next keystream block by encrypting successive values of a "counter"
  - counter can be any function which produces a sequence which is guaranteed not to repeat for a long time, although an actual counter is the simplest and most popular
the usage of a simple deterministic input function raised controversial discussions
has similar characteristics to OFB, but also allows a random-access property during decryption
well suited to operation on a multi-processor machine where blocks can be encrypted in parallel

---

# Slide 62

## CTR (Counter Mode)

62

Similar to  OFB
There are problems in repeated use of same seed (like OFB)
CTR vs OFB: using CTR you can decrypt the message starting from block i for any i

---

# Slide 63

## On the IV

63

Most modes (except ECB) require an initialization vector, or IV
  - sort of "dummy block" to kick off the process for the first real block, and to provide some randomization for the process
  - no need for the IV to be secret, in most cases, but it is important that it is never reused with the same key 
For CBC reusing an IV leaks some information about the first block of plaintext, and about any common prefix shared by the two messages
In CBC mode, the IV must, in addition, be unpredictable at encryption time
  - there is a TLS CBC IV attack
For OFB and CTR, reusing an IV destroys security

---

# Slide 64

## Analysis and comparison of block modes of operations

64

---

# Slide 65

## Recap on block modes of operations

65

There are many block operation modes
  - more than 4
Used to overcome the limitation that the same algorithm with the same key always encrypts the same plaintext block to the same ciphertext 
Since they are many, how to make a choice?

---

# Slide 66

## Methodology of analysis

66

Some questions are relevant for most modes
Can it encrypt in parallel?
Can it decrypt in parallel?
Is preprocessing useful?
Does it support ciphertext direct addressing?
What consequences for a ciphertext bit flipping?
Does it turn block encryption to stream encryption?

---

# Slide 67

## Recap schemes 1

67

ECB

CBC

---

# Slide 68

## Recap schemes 2

68

CTR

---

# Slide 69

## Comparison

69

---

